{"ast":null,"code":"import { useMemo } from 'react';\nimport { useRawCalls } from './useRawCalls';\nimport { decodeCallResult, encodeCallData } from '../helpers';\nimport { useChainId } from './useChainId';\n/**\n * Makes a call to a specific method of a specific contract and returns the value or an error if present.\n * The hook will cause the component to refresh when a new block is mined and the return value changes.\n * A syntax sugar for useRawCall that uses ABI, function name, and arguments instead of raw data.\n * If typechain contract is used in call parameter then method name and arguments will be type checked.\n * Result will be typed as well.\n *\n * @param call a single call to a contract , also see {@link Call}\n * @returns The hook returns {@link CallResult} type.\n *          That is: undefined when call didn't return yet or a object { value | error } if it did,\n *          value: any[] | undefined - array of results or undefined if error occurred,\n *          error: Error | undefined - encountered error or undefined if call was successful.\n */\n\nexport function useCall(call) {\n  var queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return useCalls([call], queryParams)[0];\n}\n/**\n * Makes calls to specific methods of specific contracts and returns values or an error if present.\n * The hook will cause the component to refresh when a new block is mined and the return values change.\n * A syntax sugar for useRawCalls that uses ABI, function name, and arguments instead of raw data.\n * @param calls a list of contract calls , also see {@link Call}.\n * @param queryParams see {@link QueryParams}.\n * @returns a list of results (see {@link CallResult} in {@link useCall} above).\n */\n\nexport function useCalls(calls) {\n  var queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var chainId = useChainId({\n    queryParams: queryParams\n  });\n  var rawCalls = useMemo(function () {\n    return calls.map(function (call) {\n      return chainId !== undefined ? encodeCallData(call, chainId) : undefined;\n    });\n  }, [JSON.stringify(calls.map(function (call) {\n    return call && {\n      address: call.contract.address.toLowerCase(),\n      method: call.method,\n      args: call.args\n    };\n  })), chainId]);\n  var results = useRawCalls(rawCalls);\n  return useMemo(function () {\n    return results.map(function (result, idx) {\n      return decodeCallResult(calls[idx], result);\n    });\n  }, [results]);\n}","map":{"version":3,"sources":["../../../../src/hooks/useCall.ts"],"names":[],"mappings":"AAAA,SAAS,OAAT,QAAwB,OAAxB;AAGA,SAAS,WAAT,QAA4B,eAA5B;AACA,SAAqB,gBAArB,EAAuC,cAAvC,QAA6D,YAA7D;AAEA,SAAS,UAAT,QAA2B,cAA3B;AAWA;;;;;;;;;;;;AAYG;;AACH,OAAM,SAAU,OAAV,CACJ,IADI,EAEyB;EAAA,IAA7B,WAA6B,uEAAF,EAAE;EAE7B,OAAO,QAAQ,CAAC,CAAC,IAAD,CAAD,EAAS,WAAT,CAAR,CAA8B,CAA9B,CAAP;AACD;AAED;;;;;;;AAOG;;AACH,OAAM,SAAU,QAAV,CAAmB,KAAnB,EAAyE;EAAA,IAA7B,WAA6B,uEAAF,EAAE;EAC7E,IAAM,OAAO,GAAG,UAAU,CAAC;IAAE,WAAW,EAAX;EAAF,CAAD,CAA1B;EAEA,IAAM,QAAQ,GAAG,OAAO,CACtB;IAAA,OAAM,KAAK,CAAC,GAAN,CAAU,UAAC,IAAD;MAAA,OAAW,OAAO,KAAK,SAAZ,GAAwB,cAAc,CAAC,IAAD,EAAO,OAAP,CAAtC,GAAwD,SAAnE;IAAA,CAAV,CAAN;EAAA,CADsB,EAEtB,CACE,IAAI,CAAC,SAAL,CACE,KAAK,CAAC,GAAN,CACE,UAAC,IAAD;IAAA,OAAU,IAAI,IAAI;MAAE,OAAO,EAAE,IAAI,CAAC,QAAL,CAAc,OAAd,CAAsB,WAAtB,EAAX;MAAgD,MAAM,EAAE,IAAI,CAAC,MAA7D;MAAqE,IAAI,EAAE,IAAI,CAAC;IAAhF,CAAlB;EAAA,CADF,CADF,CADF,EAME,OANF,CAFsB,CAAxB;EAWA,IAAM,OAAO,GAAG,WAAW,CAAC,QAAD,CAA3B;EACA,OAAO,OAAO,CAAC;IAAA,OAAM,OAAO,CAAC,GAAR,CAAY,UAAC,MAAD,EAAS,GAAT;MAAA,OAAiB,gBAAgB,CAAC,KAAK,CAAC,GAAD,CAAN,EAAa,MAAb,CAAjC;IAAA,CAAZ,CAAN;EAAA,CAAD,EAA2E,CAAC,OAAD,CAA3E,CAAd;AACD","sourceRoot":"","sourcesContent":["import { useMemo } from 'react';\nimport { useRawCalls } from './useRawCalls';\nimport { decodeCallResult, encodeCallData } from '../helpers';\nimport { useChainId } from './useChainId';\n/**\n * Makes a call to a specific method of a specific contract and returns the value or an error if present.\n * The hook will cause the component to refresh when a new block is mined and the return value changes.\n * A syntax sugar for useRawCall that uses ABI, function name, and arguments instead of raw data.\n * If typechain contract is used in call parameter then method name and arguments will be type checked.\n * Result will be typed as well.\n *\n * @param call a single call to a contract , also see {@link Call}\n * @returns The hook returns {@link CallResult} type.\n *          That is: undefined when call didn't return yet or a object { value | error } if it did,\n *          value: any[] | undefined - array of results or undefined if error occurred,\n *          error: Error | undefined - encountered error or undefined if call was successful.\n */\nexport function useCall(call, queryParams = {}) {\n    return useCalls([call], queryParams)[0];\n}\n/**\n * Makes calls to specific methods of specific contracts and returns values or an error if present.\n * The hook will cause the component to refresh when a new block is mined and the return values change.\n * A syntax sugar for useRawCalls that uses ABI, function name, and arguments instead of raw data.\n * @param calls a list of contract calls , also see {@link Call}.\n * @param queryParams see {@link QueryParams}.\n * @returns a list of results (see {@link CallResult} in {@link useCall} above).\n */\nexport function useCalls(calls, queryParams = {}) {\n    const chainId = useChainId({ queryParams });\n    const rawCalls = useMemo(() => calls.map((call) => (chainId !== undefined ? encodeCallData(call, chainId) : undefined)), [\n        JSON.stringify(calls.map((call) => call && { address: call.contract.address.toLowerCase(), method: call.method, args: call.args })),\n        chainId,\n    ]);\n    const results = useRawCalls(rawCalls);\n    return useMemo(() => results.map((result, idx) => decodeCallResult(calls[idx], result)), [results]);\n}\n//# sourceMappingURL=useCall.js.map"]},"metadata":{},"sourceType":"module"}