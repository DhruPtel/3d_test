{"ast":null,"code":"import { BufferAttribute, BufferGeometry, FileLoader, Loader } from 'three';\n\nconst _taskCache = new WeakMap();\n\nclass DRACOLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.decoderPath = '';\n    this.decoderConfig = {};\n    this.decoderBinary = null;\n    this.decoderPending = null;\n    this.workerLimit = 4;\n    this.workerPool = [];\n    this.workerNextTaskID = 1;\n    this.workerSourceURL = '';\n    this.defaultAttributeIDs = {\n      position: 'POSITION',\n      normal: 'NORMAL',\n      color: 'COLOR',\n      uv: 'TEX_COORD'\n    };\n    this.defaultAttributeTypes = {\n      position: 'Float32Array',\n      normal: 'Float32Array',\n      color: 'Float32Array',\n      uv: 'Float32Array'\n    };\n  }\n\n  setDecoderPath(path) {\n    this.decoderPath = path;\n    return this;\n  }\n\n  setDecoderConfig(config) {\n    this.decoderConfig = config;\n    return this;\n  }\n\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit;\n    return this;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, buffer => {\n      this.decodeDracoFile(buffer, onLoad).catch(onError);\n    }, onProgress, onError);\n  }\n\n  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n    const taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs\n    };\n    return this.decodeGeometry(buffer, taskConfig).then(callback);\n  }\n\n  decodeGeometry(buffer, taskConfig) {\n    const taskKey = JSON.stringify(taskConfig); // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n    // again from this thread.\n\n    if (_taskCache.has(buffer)) {\n      const cachedTask = _taskCache.get(buffer);\n\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise;\n      } else if (buffer.byteLength === 0) {\n        // Technically, it would be possible to wait for the previous task to complete,\n        // transfer the buffer back, and decode again with the second configuration. That\n        // is complex, and I don't know of any reason to decode a Draco buffer twice in\n        // different ways, so this is left unimplemented.\n        throw new Error('THREE.DRACOLoader: Unable to re-decode a buffer with different ' + 'settings. Buffer has already been transferred.');\n      }\n    } //\n\n\n    let worker;\n    const taskID = this.workerNextTaskID++;\n    const taskCost = buffer.byteLength; // Obtain a worker and assign a task, and construct a geometry instance\n    // when the task completes.\n\n    const geometryPending = this._getWorker(taskID, taskCost).then(_worker => {\n      worker = _worker;\n      return new Promise((resolve, reject) => {\n        worker._callbacks[taskID] = {\n          resolve,\n          reject\n        };\n        worker.postMessage({\n          type: 'decode',\n          id: taskID,\n          taskConfig,\n          buffer\n        }, [buffer]); // this.debug();\n      });\n    }).then(message => this._createGeometry(message.geometry)); // Remove task from the task list.\n    // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n\n\n    geometryPending.catch(() => true).then(() => {\n      if (worker && taskID) {\n        this._releaseTask(worker, taskID); // this.debug();\n\n      }\n    }); // Cache the task result.\n\n    _taskCache.set(buffer, {\n      key: taskKey,\n      promise: geometryPending\n    });\n\n    return geometryPending;\n  }\n\n  _createGeometry(geometryData) {\n    const geometry = new BufferGeometry();\n\n    if (geometryData.index) {\n      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));\n    }\n\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      const attribute = geometryData.attributes[i];\n      const name = attribute.name;\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      geometry.setAttribute(name, new BufferAttribute(array, itemSize));\n    }\n\n    return geometry;\n  }\n\n  _loadLibrary(url, responseType) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.decoderPath);\n    loader.setResponseType(responseType);\n    loader.setWithCredentials(this.withCredentials);\n    return new Promise((resolve, reject) => {\n      loader.load(url, resolve, undefined, reject);\n    });\n  }\n\n  preload() {\n    this._initDecoder();\n\n    return this;\n  }\n\n  _initDecoder() {\n    if (this.decoderPending) return this.decoderPending;\n    const useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';\n    const librariesPending = [];\n\n    if (useJS) {\n      librariesPending.push(this._loadLibrary('draco_decoder.js', 'text'));\n    } else {\n      librariesPending.push(this._loadLibrary('draco_wasm_wrapper.js', 'text'));\n      librariesPending.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'));\n    }\n\n    this.decoderPending = Promise.all(librariesPending).then(libraries => {\n      const jsContent = libraries[0];\n\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1];\n      }\n\n      const fn = DRACOWorker.toString();\n      const body = ['/* draco decoder */', jsContent, '', '/* worker */', fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))].join('\\n');\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n    });\n    return this.decoderPending;\n  }\n\n  _getWorker(taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker = new Worker(this.workerSourceURL);\n        worker._callbacks = {};\n        worker._taskCosts = {};\n        worker._taskLoad = 0;\n        worker.postMessage({\n          type: 'init',\n          decoderConfig: this.decoderConfig\n        });\n\n        worker.onmessage = function (e) {\n          const message = e.data;\n\n          switch (message.type) {\n            case 'decode':\n              worker._callbacks[message.id].resolve(message);\n\n              break;\n\n            case 'error':\n              worker._callbacks[message.id].reject(message);\n\n              break;\n\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n          }\n        };\n\n        this.workerPool.push(worker);\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n\n      const worker = this.workerPool[this.workerPool.length - 1];\n      worker._taskCosts[taskID] = taskCost;\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  }\n\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID];\n    delete worker._callbacks[taskID];\n    delete worker._taskCosts[taskID];\n  }\n\n  debug() {\n    console.log('Task load: ', this.workerPool.map(worker => worker._taskLoad));\n  }\n\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate();\n    }\n\n    this.workerPool.length = 0;\n    return this;\n  }\n\n}\n/* WEB WORKER */\n\n\nfunction DRACOWorker() {\n  let decoderConfig;\n  let decoderPending;\n\n  onmessage = function (e) {\n    const message = e.data;\n\n    switch (message.type) {\n      case 'init':\n        decoderConfig = message.decoderConfig;\n        decoderPending = new Promise(function (resolve\n        /*, reject*/\n        ) {\n          decoderConfig.onModuleLoaded = function (draco) {\n            // Module is Promise-like. Wrap before resolving to avoid loop.\n            resolve({\n              draco: draco\n            });\n          };\n\n          DracoDecoderModule(decoderConfig); // eslint-disable-line no-undef\n        });\n        break;\n\n      case 'decode':\n        const buffer = message.buffer;\n        const taskConfig = message.taskConfig;\n        decoderPending.then(module => {\n          const draco = module.draco;\n          const decoder = new draco.Decoder();\n          const decoderBuffer = new draco.DecoderBuffer();\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n\n          try {\n            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n            const buffers = geometry.attributes.map(attr => attr.array.buffer);\n            if (geometry.index) buffers.push(geometry.index.array.buffer);\n            self.postMessage({\n              type: 'decode',\n              id: message.id,\n              geometry\n            }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({\n              type: 'error',\n              id: message.id,\n              error: error.message\n            });\n          } finally {\n            draco.destroy(decoderBuffer);\n            draco.destroy(decoder);\n          }\n        });\n        break;\n    }\n  };\n\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    const attributeIDs = taskConfig.attributeIDs;\n    const attributeTypes = taskConfig.attributeTypes;\n    let dracoGeometry;\n    let decodingStatus;\n    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh();\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud();\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n    } else {\n      throw new Error('THREE.DRACOLoader: Unexpected geometry type.');\n    }\n\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error('THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg());\n    }\n\n    const geometry = {\n      index: null,\n      attributes: []\n    }; // Gather all vertex attributes.\n\n    for (const attributeName in attributeIDs) {\n      const attributeType = self[attributeTypes[attributeName]];\n      let attribute;\n      let attributeID; // A Draco file may be created with default vertex attributes, whose attribute IDs\n      // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n      // a Draco file may contain a custom set of attributes, identified by known unique\n      // IDs. glTF files always do the latter, and `.drc` files typically do the former.\n\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName];\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n        if (attributeID === -1) continue;\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n      }\n\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n    } // Add index.\n\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n    }\n\n    draco.destroy(dracoGeometry);\n    return geometry;\n  }\n\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * 4;\n\n    const ptr = draco._malloc(byteLength);\n\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n\n    draco._free(ptr);\n\n    return {\n      array: index,\n      itemSize: 1\n    };\n  }\n\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    const numComponents = attribute.num_components();\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(draco, attributeType);\n\n    const ptr = draco._malloc(byteLength);\n\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n\n    draco._free(ptr);\n\n    return {\n      name: attributeName,\n      array: array,\n      itemSize: numComponents\n    };\n  }\n\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32;\n\n      case Int8Array:\n        return draco.DT_INT8;\n\n      case Int16Array:\n        return draco.DT_INT16;\n\n      case Int32Array:\n        return draco.DT_INT32;\n\n      case Uint8Array:\n        return draco.DT_UINT8;\n\n      case Uint16Array:\n        return draco.DT_UINT16;\n\n      case Uint32Array:\n        return draco.DT_UINT32;\n    }\n  }\n}\n\nexport { DRACOLoader };","map":{"version":3,"names":["BufferAttribute","BufferGeometry","FileLoader","Loader","_taskCache","WeakMap","DRACOLoader","constructor","manager","decoderPath","decoderConfig","decoderBinary","decoderPending","workerLimit","workerPool","workerNextTaskID","workerSourceURL","defaultAttributeIDs","position","normal","color","uv","defaultAttributeTypes","setDecoderPath","path","setDecoderConfig","config","setWorkerLimit","load","url","onLoad","onProgress","onError","loader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","buffer","decodeDracoFile","catch","callback","attributeIDs","attributeTypes","taskConfig","useUniqueIDs","decodeGeometry","then","taskKey","JSON","stringify","has","cachedTask","get","key","promise","byteLength","Error","worker","taskID","taskCost","geometryPending","_getWorker","_worker","Promise","resolve","reject","_callbacks","postMessage","type","id","message","_createGeometry","geometry","_releaseTask","set","geometryData","index","setIndex","array","i","attributes","length","attribute","name","itemSize","setAttribute","_loadLibrary","responseType","undefined","preload","_initDecoder","useJS","WebAssembly","librariesPending","push","all","libraries","jsContent","wasmBinary","fn","DRACOWorker","toString","body","substring","indexOf","lastIndexOf","join","URL","createObjectURL","Blob","Worker","_taskCosts","_taskLoad","onmessage","e","data","console","error","sort","a","b","debug","log","map","dispose","terminate","onModuleLoaded","draco","DracoDecoderModule","module","decoder","Decoder","decoderBuffer","DecoderBuffer","Init","Int8Array","buffers","attr","self","destroy","dracoGeometry","decodingStatus","geometryType","GetEncodedGeometryType","TRIANGULAR_MESH","Mesh","DecodeBufferToMesh","POINT_CLOUD","PointCloud","DecodeBufferToPointCloud","ok","ptr","error_msg","attributeName","attributeType","attributeID","GetAttributeByUniqueId","GetAttributeId","GetAttribute","decodeAttribute","decodeIndex","numFaces","num_faces","numIndices","_malloc","GetTrianglesUInt32Array","Uint32Array","HEAPF32","slice","_free","numComponents","num_components","numPoints","num_points","numValues","BYTES_PER_ELEMENT","dataType","getDracoDataType","GetAttributeDataArrayForAllPoints","Float32Array","DT_FLOAT32","DT_INT8","Int16Array","DT_INT16","Int32Array","DT_INT32","Uint8Array","DT_UINT8","Uint16Array","DT_UINT16","DT_UINT32"],"sources":["C:/Users/User/don1/depend/node_modules/three/examples/jsm/loaders/DRACOLoader.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFileLoader,\n\tLoader\n} from 'three';\n\nconst _taskCache = new WeakMap();\n\nclass DRACOLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.decoderPath = '';\n\t\tthis.decoderConfig = {};\n\t\tthis.decoderBinary = null;\n\t\tthis.decoderPending = null;\n\n\t\tthis.workerLimit = 4;\n\t\tthis.workerPool = [];\n\t\tthis.workerNextTaskID = 1;\n\t\tthis.workerSourceURL = '';\n\n\t\tthis.defaultAttributeIDs = {\n\t\t\tposition: 'POSITION',\n\t\t\tnormal: 'NORMAL',\n\t\t\tcolor: 'COLOR',\n\t\t\tuv: 'TEX_COORD'\n\t\t};\n\t\tthis.defaultAttributeTypes = {\n\t\t\tposition: 'Float32Array',\n\t\t\tnormal: 'Float32Array',\n\t\t\tcolor: 'Float32Array',\n\t\t\tuv: 'Float32Array'\n\t\t};\n\n\t}\n\n\tsetDecoderPath( path ) {\n\n\t\tthis.decoderPath = path;\n\n\t\treturn this;\n\n\t}\n\n\tsetDecoderConfig( config ) {\n\n\t\tthis.decoderConfig = config;\n\n\t\treturn this;\n\n\t}\n\n\tsetWorkerLimit( workerLimit ) {\n\n\t\tthis.workerLimit = workerLimit;\n\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst loader = new FileLoader( this.manager );\n\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, ( buffer ) => {\n\n\t\t\tthis.decodeDracoFile( buffer, onLoad ).catch( onError );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tdecodeDracoFile( buffer, callback, attributeIDs, attributeTypes ) {\n\n\t\tconst taskConfig = {\n\t\t\tattributeIDs: attributeIDs || this.defaultAttributeIDs,\n\t\t\tattributeTypes: attributeTypes || this.defaultAttributeTypes,\n\t\t\tuseUniqueIDs: !! attributeIDs\n\t\t};\n\n\t\treturn this.decodeGeometry( buffer, taskConfig ).then( callback );\n\n\t}\n\n\tdecodeGeometry( buffer, taskConfig ) {\n\n\t\tconst taskKey = JSON.stringify( taskConfig );\n\n\t\t// Check for an existing task using this buffer. A transferred buffer cannot be transferred\n\t\t// again from this thread.\n\t\tif ( _taskCache.has( buffer ) ) {\n\n\t\t\tconst cachedTask = _taskCache.get( buffer );\n\n\t\t\tif ( cachedTask.key === taskKey ) {\n\n\t\t\t\treturn cachedTask.promise;\n\n\t\t\t} else if ( buffer.byteLength === 0 ) {\n\n\t\t\t\t// Technically, it would be possible to wait for the previous task to complete,\n\t\t\t\t// transfer the buffer back, and decode again with the second configuration. That\n\t\t\t\t// is complex, and I don't know of any reason to decode a Draco buffer twice in\n\t\t\t\t// different ways, so this is left unimplemented.\n\t\t\t\tthrow new Error(\n\n\t\t\t\t\t'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +\n\t\t\t\t\t'settings. Buffer has already been transferred.'\n\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tlet worker;\n\t\tconst taskID = this.workerNextTaskID ++;\n\t\tconst taskCost = buffer.byteLength;\n\n\t\t// Obtain a worker and assign a task, and construct a geometry instance\n\t\t// when the task completes.\n\t\tconst geometryPending = this._getWorker( taskID, taskCost )\n\t\t\t.then( ( _worker ) => {\n\n\t\t\t\tworker = _worker;\n\n\t\t\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\t\t\tworker._callbacks[ taskID ] = { resolve, reject };\n\n\t\t\t\t\tworker.postMessage( { type: 'decode', id: taskID, taskConfig, buffer }, [ buffer ] );\n\n\t\t\t\t\t// this.debug();\n\n\t\t\t\t} );\n\n\t\t\t} )\n\t\t\t.then( ( message ) => this._createGeometry( message.geometry ) );\n\n\t\t// Remove task from the task list.\n\t\t// Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n\t\tgeometryPending\n\t\t\t.catch( () => true )\n\t\t\t.then( () => {\n\n\t\t\t\tif ( worker && taskID ) {\n\n\t\t\t\t\tthis._releaseTask( worker, taskID );\n\n\t\t\t\t\t// this.debug();\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t// Cache the task result.\n\t\t_taskCache.set( buffer, {\n\n\t\t\tkey: taskKey,\n\t\t\tpromise: geometryPending\n\n\t\t} );\n\n\t\treturn geometryPending;\n\n\t}\n\n\t_createGeometry( geometryData ) {\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tif ( geometryData.index ) {\n\n\t\t\tgeometry.setIndex( new BufferAttribute( geometryData.index.array, 1 ) );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < geometryData.attributes.length; i ++ ) {\n\n\t\t\tconst attribute = geometryData.attributes[ i ];\n\t\t\tconst name = attribute.name;\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tgeometry.setAttribute( name, new BufferAttribute( array, itemSize ) );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n\t_loadLibrary( url, responseType ) {\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.decoderPath );\n\t\tloader.setResponseType( responseType );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\treturn new Promise( ( resolve, reject ) => {\n\n\t\t\tloader.load( url, resolve, undefined, reject );\n\n\t\t} );\n\n\t}\n\n\tpreload() {\n\n\t\tthis._initDecoder();\n\n\t\treturn this;\n\n\t}\n\n\t_initDecoder() {\n\n\t\tif ( this.decoderPending ) return this.decoderPending;\n\n\t\tconst useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';\n\t\tconst librariesPending = [];\n\n\t\tif ( useJS ) {\n\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_decoder.js', 'text' ) );\n\n\t\t} else {\n\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_wasm_wrapper.js', 'text' ) );\n\t\t\tlibrariesPending.push( this._loadLibrary( 'draco_decoder.wasm', 'arraybuffer' ) );\n\n\t\t}\n\n\t\tthis.decoderPending = Promise.all( librariesPending )\n\t\t\t.then( ( libraries ) => {\n\n\t\t\t\tconst jsContent = libraries[ 0 ];\n\n\t\t\t\tif ( ! useJS ) {\n\n\t\t\t\t\tthis.decoderConfig.wasmBinary = libraries[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t\tconst fn = DRACOWorker.toString();\n\n\t\t\t\tconst body = [\n\t\t\t\t\t'/* draco decoder */',\n\t\t\t\t\tjsContent,\n\t\t\t\t\t'',\n\t\t\t\t\t'/* worker */',\n\t\t\t\t\tfn.substring( fn.indexOf( '{' ) + 1, fn.lastIndexOf( '}' ) )\n\t\t\t\t].join( '\\n' );\n\n\t\t\t\tthis.workerSourceURL = URL.createObjectURL( new Blob( [ body ] ) );\n\n\t\t\t} );\n\n\t\treturn this.decoderPending;\n\n\t}\n\n\t_getWorker( taskID, taskCost ) {\n\n\t\treturn this._initDecoder().then( () => {\n\n\t\t\tif ( this.workerPool.length < this.workerLimit ) {\n\n\t\t\t\tconst worker = new Worker( this.workerSourceURL );\n\n\t\t\t\tworker._callbacks = {};\n\t\t\t\tworker._taskCosts = {};\n\t\t\t\tworker._taskLoad = 0;\n\n\t\t\t\tworker.postMessage( { type: 'init', decoderConfig: this.decoderConfig } );\n\n\t\t\t\tworker.onmessage = function ( e ) {\n\n\t\t\t\t\tconst message = e.data;\n\n\t\t\t\t\tswitch ( message.type ) {\n\n\t\t\t\t\t\tcase 'decode':\n\t\t\t\t\t\t\tworker._callbacks[ message.id ].resolve( message );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'error':\n\t\t\t\t\t\t\tworker._callbacks[ message.id ].reject( message );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"' );\n\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tthis.workerPool.push( worker );\n\n\t\t\t} else {\n\n\t\t\t\tthis.workerPool.sort( function ( a, b ) {\n\n\t\t\t\t\treturn a._taskLoad > b._taskLoad ? - 1 : 1;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst worker = this.workerPool[ this.workerPool.length - 1 ];\n\t\t\tworker._taskCosts[ taskID ] = taskCost;\n\t\t\tworker._taskLoad += taskCost;\n\t\t\treturn worker;\n\n\t\t} );\n\n\t}\n\n\t_releaseTask( worker, taskID ) {\n\n\t\tworker._taskLoad -= worker._taskCosts[ taskID ];\n\t\tdelete worker._callbacks[ taskID ];\n\t\tdelete worker._taskCosts[ taskID ];\n\n\t}\n\n\tdebug() {\n\n\t\tconsole.log( 'Task load: ', this.workerPool.map( ( worker ) => worker._taskLoad ) );\n\n\t}\n\n\tdispose() {\n\n\t\tfor ( let i = 0; i < this.workerPool.length; ++ i ) {\n\n\t\t\tthis.workerPool[ i ].terminate();\n\n\t\t}\n\n\t\tthis.workerPool.length = 0;\n\n\t\treturn this;\n\n\t}\n\n}\n\n/* WEB WORKER */\n\nfunction DRACOWorker() {\n\n\tlet decoderConfig;\n\tlet decoderPending;\n\n\tonmessage = function ( e ) {\n\n\t\tconst message = e.data;\n\n\t\tswitch ( message.type ) {\n\n\t\t\tcase 'init':\n\t\t\t\tdecoderConfig = message.decoderConfig;\n\t\t\t\tdecoderPending = new Promise( function ( resolve/*, reject*/ ) {\n\n\t\t\t\t\tdecoderConfig.onModuleLoaded = function ( draco ) {\n\n\t\t\t\t\t\t// Module is Promise-like. Wrap before resolving to avoid loop.\n\t\t\t\t\t\tresolve( { draco: draco } );\n\n\t\t\t\t\t};\n\n\t\t\t\t\tDracoDecoderModule( decoderConfig ); // eslint-disable-line no-undef\n\n\t\t\t\t} );\n\t\t\t\tbreak;\n\n\t\t\tcase 'decode':\n\t\t\t\tconst buffer = message.buffer;\n\t\t\t\tconst taskConfig = message.taskConfig;\n\t\t\t\tdecoderPending.then( ( module ) => {\n\n\t\t\t\t\tconst draco = module.draco;\n\t\t\t\t\tconst decoder = new draco.Decoder();\n\t\t\t\t\tconst decoderBuffer = new draco.DecoderBuffer();\n\t\t\t\t\tdecoderBuffer.Init( new Int8Array( buffer ), buffer.byteLength );\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tconst geometry = decodeGeometry( draco, decoder, decoderBuffer, taskConfig );\n\n\t\t\t\t\t\tconst buffers = geometry.attributes.map( ( attr ) => attr.array.buffer );\n\n\t\t\t\t\t\tif ( geometry.index ) buffers.push( geometry.index.array.buffer );\n\n\t\t\t\t\t\tself.postMessage( { type: 'decode', id: message.id, geometry }, buffers );\n\n\t\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t\tconsole.error( error );\n\n\t\t\t\t\t\tself.postMessage( { type: 'error', id: message.id, error: error.message } );\n\n\t\t\t\t\t} finally {\n\n\t\t\t\t\t\tdraco.destroy( decoderBuffer );\n\t\t\t\t\t\tdraco.destroy( decoder );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t};\n\n\tfunction decodeGeometry( draco, decoder, decoderBuffer, taskConfig ) {\n\n\t\tconst attributeIDs = taskConfig.attributeIDs;\n\t\tconst attributeTypes = taskConfig.attributeTypes;\n\n\t\tlet dracoGeometry;\n\t\tlet decodingStatus;\n\n\t\tconst geometryType = decoder.GetEncodedGeometryType( decoderBuffer );\n\n\t\tif ( geometryType === draco.TRIANGULAR_MESH ) {\n\n\t\t\tdracoGeometry = new draco.Mesh();\n\t\t\tdecodingStatus = decoder.DecodeBufferToMesh( decoderBuffer, dracoGeometry );\n\n\t\t} else if ( geometryType === draco.POINT_CLOUD ) {\n\n\t\t\tdracoGeometry = new draco.PointCloud();\n\t\t\tdecodingStatus = decoder.DecodeBufferToPointCloud( decoderBuffer, dracoGeometry );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.DRACOLoader: Unexpected geometry type.' );\n\n\t\t}\n\n\t\tif ( ! decodingStatus.ok() || dracoGeometry.ptr === 0 ) {\n\n\t\t\tthrow new Error( 'THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg() );\n\n\t\t}\n\n\t\tconst geometry = { index: null, attributes: [] };\n\n\t\t// Gather all vertex attributes.\n\t\tfor ( const attributeName in attributeIDs ) {\n\n\t\t\tconst attributeType = self[ attributeTypes[ attributeName ] ];\n\n\t\t\tlet attribute;\n\t\t\tlet attributeID;\n\n\t\t\t// A Draco file may be created with default vertex attributes, whose attribute IDs\n\t\t\t// are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n\t\t\t// a Draco file may contain a custom set of attributes, identified by known unique\n\t\t\t// IDs. glTF files always do the latter, and `.drc` files typically do the former.\n\t\t\tif ( taskConfig.useUniqueIDs ) {\n\n\t\t\t\tattributeID = attributeIDs[ attributeName ];\n\t\t\t\tattribute = decoder.GetAttributeByUniqueId( dracoGeometry, attributeID );\n\n\t\t\t} else {\n\n\t\t\t\tattributeID = decoder.GetAttributeId( dracoGeometry, draco[ attributeIDs[ attributeName ] ] );\n\n\t\t\t\tif ( attributeID === - 1 ) continue;\n\n\t\t\t\tattribute = decoder.GetAttribute( dracoGeometry, attributeID );\n\n\t\t\t}\n\n\t\t\tgeometry.attributes.push( decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) );\n\n\t\t}\n\n\t\t// Add index.\n\t\tif ( geometryType === draco.TRIANGULAR_MESH ) {\n\n\t\t\tgeometry.index = decodeIndex( draco, decoder, dracoGeometry );\n\n\t\t}\n\n\t\tdraco.destroy( dracoGeometry );\n\n\t\treturn geometry;\n\n\t}\n\n\tfunction decodeIndex( draco, decoder, dracoGeometry ) {\n\n\t\tconst numFaces = dracoGeometry.num_faces();\n\t\tconst numIndices = numFaces * 3;\n\t\tconst byteLength = numIndices * 4;\n\n\t\tconst ptr = draco._malloc( byteLength );\n\t\tdecoder.GetTrianglesUInt32Array( dracoGeometry, byteLength, ptr );\n\t\tconst index = new Uint32Array( draco.HEAPF32.buffer, ptr, numIndices ).slice();\n\t\tdraco._free( ptr );\n\n\t\treturn { array: index, itemSize: 1 };\n\n\t}\n\n\tfunction decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) {\n\n\t\tconst numComponents = attribute.num_components();\n\t\tconst numPoints = dracoGeometry.num_points();\n\t\tconst numValues = numPoints * numComponents;\n\t\tconst byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n\t\tconst dataType = getDracoDataType( draco, attributeType );\n\n\t\tconst ptr = draco._malloc( byteLength );\n\t\tdecoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, dataType, byteLength, ptr );\n\t\tconst array = new attributeType( draco.HEAPF32.buffer, ptr, numValues ).slice();\n\t\tdraco._free( ptr );\n\n\t\treturn {\n\t\t\tname: attributeName,\n\t\t\tarray: array,\n\t\t\titemSize: numComponents\n\t\t};\n\n\t}\n\n\tfunction getDracoDataType( draco, attributeType ) {\n\n\t\tswitch ( attributeType ) {\n\n\t\t\tcase Float32Array: return draco.DT_FLOAT32;\n\t\t\tcase Int8Array: return draco.DT_INT8;\n\t\t\tcase Int16Array: return draco.DT_INT16;\n\t\t\tcase Int32Array: return draco.DT_INT32;\n\t\t\tcase Uint8Array: return draco.DT_UINT8;\n\t\t\tcase Uint16Array: return draco.DT_UINT16;\n\t\t\tcase Uint32Array: return draco.DT_UINT32;\n\n\t\t}\n\n\t}\n\n}\n\nexport { DRACOLoader };\n"],"mappings":"AAAA,SACCA,eADD,EAECC,cAFD,EAGCC,UAHD,EAICC,MAJD,QAKO,OALP;;AAOA,MAAMC,UAAU,GAAG,IAAIC,OAAJ,EAAnB;;AAEA,MAAMC,WAAN,SAA0BH,MAA1B,CAAiC;EAEhCI,WAAW,CAAEC,OAAF,EAAY;IAEtB,MAAOA,OAAP;IAEA,KAAKC,WAAL,GAAmB,EAAnB;IACA,KAAKC,aAAL,GAAqB,EAArB;IACA,KAAKC,aAAL,GAAqB,IAArB;IACA,KAAKC,cAAL,GAAsB,IAAtB;IAEA,KAAKC,WAAL,GAAmB,CAAnB;IACA,KAAKC,UAAL,GAAkB,EAAlB;IACA,KAAKC,gBAAL,GAAwB,CAAxB;IACA,KAAKC,eAAL,GAAuB,EAAvB;IAEA,KAAKC,mBAAL,GAA2B;MAC1BC,QAAQ,EAAE,UADgB;MAE1BC,MAAM,EAAE,QAFkB;MAG1BC,KAAK,EAAE,OAHmB;MAI1BC,EAAE,EAAE;IAJsB,CAA3B;IAMA,KAAKC,qBAAL,GAA6B;MAC5BJ,QAAQ,EAAE,cADkB;MAE5BC,MAAM,EAAE,cAFoB;MAG5BC,KAAK,EAAE,cAHqB;MAI5BC,EAAE,EAAE;IAJwB,CAA7B;EAOA;;EAEDE,cAAc,CAAEC,IAAF,EAAS;IAEtB,KAAKf,WAAL,GAAmBe,IAAnB;IAEA,OAAO,IAAP;EAEA;;EAEDC,gBAAgB,CAAEC,MAAF,EAAW;IAE1B,KAAKhB,aAAL,GAAqBgB,MAArB;IAEA,OAAO,IAAP;EAEA;;EAEDC,cAAc,CAAEd,WAAF,EAAgB;IAE7B,KAAKA,WAAL,GAAmBA,WAAnB;IAEA,OAAO,IAAP;EAEA;;EAEDe,IAAI,CAAEC,GAAF,EAAOC,MAAP,EAAeC,UAAf,EAA2BC,OAA3B,EAAqC;IAExC,MAAMC,MAAM,GAAG,IAAI/B,UAAJ,CAAgB,KAAKM,OAArB,CAAf;IAEAyB,MAAM,CAACC,OAAP,CAAgB,KAAKV,IAArB;IACAS,MAAM,CAACE,eAAP,CAAwB,aAAxB;IACAF,MAAM,CAACG,gBAAP,CAAyB,KAAKC,aAA9B;IACAJ,MAAM,CAACK,kBAAP,CAA2B,KAAKC,eAAhC;IAEAN,MAAM,CAACL,IAAP,CAAaC,GAAb,EAAoBW,MAAF,IAAc;MAE/B,KAAKC,eAAL,CAAsBD,MAAtB,EAA8BV,MAA9B,EAAuCY,KAAvC,CAA8CV,OAA9C;IAEA,CAJD,EAIGD,UAJH,EAIeC,OAJf;EAMA;;EAEDS,eAAe,CAAED,MAAF,EAAUG,QAAV,EAAoBC,YAApB,EAAkCC,cAAlC,EAAmD;IAEjE,MAAMC,UAAU,GAAG;MAClBF,YAAY,EAAEA,YAAY,IAAI,KAAK3B,mBADjB;MAElB4B,cAAc,EAAEA,cAAc,IAAI,KAAKvB,qBAFrB;MAGlByB,YAAY,EAAE,CAAC,CAAEH;IAHC,CAAnB;IAMA,OAAO,KAAKI,cAAL,CAAqBR,MAArB,EAA6BM,UAA7B,EAA0CG,IAA1C,CAAgDN,QAAhD,CAAP;EAEA;;EAEDK,cAAc,CAAER,MAAF,EAAUM,UAAV,EAAuB;IAEpC,MAAMI,OAAO,GAAGC,IAAI,CAACC,SAAL,CAAgBN,UAAhB,CAAhB,CAFoC,CAIpC;IACA;;IACA,IAAK1C,UAAU,CAACiD,GAAX,CAAgBb,MAAhB,CAAL,EAAgC;MAE/B,MAAMc,UAAU,GAAGlD,UAAU,CAACmD,GAAX,CAAgBf,MAAhB,CAAnB;;MAEA,IAAKc,UAAU,CAACE,GAAX,KAAmBN,OAAxB,EAAkC;QAEjC,OAAOI,UAAU,CAACG,OAAlB;MAEA,CAJD,MAIO,IAAKjB,MAAM,CAACkB,UAAP,KAAsB,CAA3B,EAA+B;QAErC;QACA;QACA;QACA;QACA,MAAM,IAAIC,KAAJ,CAEL,oEACA,gDAHK,CAAN;MAOA;IAED,CA7BmC,CA+BpC;;;IAEA,IAAIC,MAAJ;IACA,MAAMC,MAAM,GAAG,KAAK9C,gBAAL,EAAf;IACA,MAAM+C,QAAQ,GAAGtB,MAAM,CAACkB,UAAxB,CAnCoC,CAqCpC;IACA;;IACA,MAAMK,eAAe,GAAG,KAAKC,UAAL,CAAiBH,MAAjB,EAAyBC,QAAzB,EACtBb,IADsB,CACdgB,OAAF,IAAe;MAErBL,MAAM,GAAGK,OAAT;MAEA,OAAO,IAAIC,OAAJ,CAAa,CAAEC,OAAF,EAAWC,MAAX,KAAuB;QAE1CR,MAAM,CAACS,UAAP,CAAmBR,MAAnB,IAA8B;UAAEM,OAAF;UAAWC;QAAX,CAA9B;QAEAR,MAAM,CAACU,WAAP,CAAoB;UAAEC,IAAI,EAAE,QAAR;UAAkBC,EAAE,EAAEX,MAAtB;UAA8Bf,UAA9B;UAA0CN;QAA1C,CAApB,EAAwE,CAAEA,MAAF,CAAxE,EAJ0C,CAM1C;MAEA,CARM,CAAP;IAUA,CAfsB,EAgBtBS,IAhBsB,CAgBdwB,OAAF,IAAe,KAAKC,eAAL,CAAsBD,OAAO,CAACE,QAA9B,CAhBC,CAAxB,CAvCoC,CAyDpC;IACA;;;IACAZ,eAAe,CACbrB,KADF,CACS,MAAM,IADf,EAEEO,IAFF,CAEQ,MAAM;MAEZ,IAAKW,MAAM,IAAIC,MAAf,EAAwB;QAEvB,KAAKe,YAAL,CAAmBhB,MAAnB,EAA2BC,MAA3B,EAFuB,CAIvB;;MAEA;IAED,CAZF,EA3DoC,CAyEpC;;IACAzD,UAAU,CAACyE,GAAX,CAAgBrC,MAAhB,EAAwB;MAEvBgB,GAAG,EAAEN,OAFkB;MAGvBO,OAAO,EAAEM;IAHc,CAAxB;;IAOA,OAAOA,eAAP;EAEA;;EAEDW,eAAe,CAAEI,YAAF,EAAiB;IAE/B,MAAMH,QAAQ,GAAG,IAAI1E,cAAJ,EAAjB;;IAEA,IAAK6E,YAAY,CAACC,KAAlB,EAA0B;MAEzBJ,QAAQ,CAACK,QAAT,CAAmB,IAAIhF,eAAJ,CAAqB8E,YAAY,CAACC,KAAb,CAAmBE,KAAxC,EAA+C,CAA/C,CAAnB;IAEA;;IAED,KAAM,IAAIC,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGJ,YAAY,CAACK,UAAb,CAAwBC,MAA7C,EAAqDF,CAAC,EAAtD,EAA4D;MAE3D,MAAMG,SAAS,GAAGP,YAAY,CAACK,UAAb,CAAyBD,CAAzB,CAAlB;MACA,MAAMI,IAAI,GAAGD,SAAS,CAACC,IAAvB;MACA,MAAML,KAAK,GAAGI,SAAS,CAACJ,KAAxB;MACA,MAAMM,QAAQ,GAAGF,SAAS,CAACE,QAA3B;MAEAZ,QAAQ,CAACa,YAAT,CAAuBF,IAAvB,EAA6B,IAAItF,eAAJ,CAAqBiF,KAArB,EAA4BM,QAA5B,CAA7B;IAEA;;IAED,OAAOZ,QAAP;EAEA;;EAEDc,YAAY,CAAE5D,GAAF,EAAO6D,YAAP,EAAsB;IAEjC,MAAMzD,MAAM,GAAG,IAAI/B,UAAJ,CAAgB,KAAKM,OAArB,CAAf;IACAyB,MAAM,CAACC,OAAP,CAAgB,KAAKzB,WAArB;IACAwB,MAAM,CAACE,eAAP,CAAwBuD,YAAxB;IACAzD,MAAM,CAACK,kBAAP,CAA2B,KAAKC,eAAhC;IAEA,OAAO,IAAI2B,OAAJ,CAAa,CAAEC,OAAF,EAAWC,MAAX,KAAuB;MAE1CnC,MAAM,CAACL,IAAP,CAAaC,GAAb,EAAkBsC,OAAlB,EAA2BwB,SAA3B,EAAsCvB,MAAtC;IAEA,CAJM,CAAP;EAMA;;EAEDwB,OAAO,GAAG;IAET,KAAKC,YAAL;;IAEA,OAAO,IAAP;EAEA;;EAEDA,YAAY,GAAG;IAEd,IAAK,KAAKjF,cAAV,EAA2B,OAAO,KAAKA,cAAZ;IAE3B,MAAMkF,KAAK,GAAG,OAAOC,WAAP,KAAuB,QAAvB,IAAmC,KAAKrF,aAAL,CAAmB6D,IAAnB,KAA4B,IAA7E;IACA,MAAMyB,gBAAgB,GAAG,EAAzB;;IAEA,IAAKF,KAAL,EAAa;MAEZE,gBAAgB,CAACC,IAAjB,CAAuB,KAAKR,YAAL,CAAmB,kBAAnB,EAAuC,MAAvC,CAAvB;IAEA,CAJD,MAIO;MAENO,gBAAgB,CAACC,IAAjB,CAAuB,KAAKR,YAAL,CAAmB,uBAAnB,EAA4C,MAA5C,CAAvB;MACAO,gBAAgB,CAACC,IAAjB,CAAuB,KAAKR,YAAL,CAAmB,oBAAnB,EAAyC,aAAzC,CAAvB;IAEA;;IAED,KAAK7E,cAAL,GAAsBsD,OAAO,CAACgC,GAAR,CAAaF,gBAAb,EACpB/C,IADoB,CACZkD,SAAF,IAAiB;MAEvB,MAAMC,SAAS,GAAGD,SAAS,CAAE,CAAF,CAA3B;;MAEA,IAAK,CAAEL,KAAP,EAAe;QAEd,KAAKpF,aAAL,CAAmB2F,UAAnB,GAAgCF,SAAS,CAAE,CAAF,CAAzC;MAEA;;MAED,MAAMG,EAAE,GAAGC,WAAW,CAACC,QAAZ,EAAX;MAEA,MAAMC,IAAI,GAAG,CACZ,qBADY,EAEZL,SAFY,EAGZ,EAHY,EAIZ,cAJY,EAKZE,EAAE,CAACI,SAAH,CAAcJ,EAAE,CAACK,OAAH,CAAY,GAAZ,IAAoB,CAAlC,EAAqCL,EAAE,CAACM,WAAH,CAAgB,GAAhB,CAArC,CALY,EAMXC,IANW,CAML,IANK,CAAb;MAQA,KAAK7F,eAAL,GAAuB8F,GAAG,CAACC,eAAJ,CAAqB,IAAIC,IAAJ,CAAU,CAAEP,IAAF,CAAV,CAArB,CAAvB;IAEA,CAvBoB,CAAtB;IAyBA,OAAO,KAAK7F,cAAZ;EAEA;;EAEDoD,UAAU,CAAEH,MAAF,EAAUC,QAAV,EAAqB;IAE9B,OAAO,KAAK+B,YAAL,GAAoB5C,IAApB,CAA0B,MAAM;MAEtC,IAAK,KAAKnC,UAAL,CAAgBsE,MAAhB,GAAyB,KAAKvE,WAAnC,EAAiD;QAEhD,MAAM+C,MAAM,GAAG,IAAIqD,MAAJ,CAAY,KAAKjG,eAAjB,CAAf;QAEA4C,MAAM,CAACS,UAAP,GAAoB,EAApB;QACAT,MAAM,CAACsD,UAAP,GAAoB,EAApB;QACAtD,MAAM,CAACuD,SAAP,GAAmB,CAAnB;QAEAvD,MAAM,CAACU,WAAP,CAAoB;UAAEC,IAAI,EAAE,MAAR;UAAgB7D,aAAa,EAAE,KAAKA;QAApC,CAApB;;QAEAkD,MAAM,CAACwD,SAAP,GAAmB,UAAWC,CAAX,EAAe;UAEjC,MAAM5C,OAAO,GAAG4C,CAAC,CAACC,IAAlB;;UAEA,QAAS7C,OAAO,CAACF,IAAjB;YAEC,KAAK,QAAL;cACCX,MAAM,CAACS,UAAP,CAAmBI,OAAO,CAACD,EAA3B,EAAgCL,OAAhC,CAAyCM,OAAzC;;cACA;;YAED,KAAK,OAAL;cACCb,MAAM,CAACS,UAAP,CAAmBI,OAAO,CAACD,EAA3B,EAAgCJ,MAAhC,CAAwCK,OAAxC;;cACA;;YAED;cACC8C,OAAO,CAACC,KAAR,CAAe,6CAA6C/C,OAAO,CAACF,IAArD,GAA4D,GAA3E;UAXF;QAeA,CAnBD;;QAqBA,KAAKzD,UAAL,CAAgBmF,IAAhB,CAAsBrC,MAAtB;MAEA,CAjCD,MAiCO;QAEN,KAAK9C,UAAL,CAAgB2G,IAAhB,CAAsB,UAAWC,CAAX,EAAcC,CAAd,EAAkB;UAEvC,OAAOD,CAAC,CAACP,SAAF,GAAcQ,CAAC,CAACR,SAAhB,GAA4B,CAAE,CAA9B,GAAkC,CAAzC;QAEA,CAJD;MAMA;;MAED,MAAMvD,MAAM,GAAG,KAAK9C,UAAL,CAAiB,KAAKA,UAAL,CAAgBsE,MAAhB,GAAyB,CAA1C,CAAf;MACAxB,MAAM,CAACsD,UAAP,CAAmBrD,MAAnB,IAA8BC,QAA9B;MACAF,MAAM,CAACuD,SAAP,IAAoBrD,QAApB;MACA,OAAOF,MAAP;IAEA,CAlDM,CAAP;EAoDA;;EAEDgB,YAAY,CAAEhB,MAAF,EAAUC,MAAV,EAAmB;IAE9BD,MAAM,CAACuD,SAAP,IAAoBvD,MAAM,CAACsD,UAAP,CAAmBrD,MAAnB,CAApB;IACA,OAAOD,MAAM,CAACS,UAAP,CAAmBR,MAAnB,CAAP;IACA,OAAOD,MAAM,CAACsD,UAAP,CAAmBrD,MAAnB,CAAP;EAEA;;EAED+D,KAAK,GAAG;IAEPL,OAAO,CAACM,GAAR,CAAa,aAAb,EAA4B,KAAK/G,UAAL,CAAgBgH,GAAhB,CAAuBlE,MAAF,IAAcA,MAAM,CAACuD,SAA1C,CAA5B;EAEA;;EAEDY,OAAO,GAAG;IAET,KAAM,IAAI7C,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAG,KAAKpE,UAAL,CAAgBsE,MAArC,EAA6C,EAAGF,CAAhD,EAAoD;MAEnD,KAAKpE,UAAL,CAAiBoE,CAAjB,EAAqB8C,SAArB;IAEA;;IAED,KAAKlH,UAAL,CAAgBsE,MAAhB,GAAyB,CAAzB;IAEA,OAAO,IAAP;EAEA;;AA1V+B;AA8VjC;;;AAEA,SAASmB,WAAT,GAAuB;EAEtB,IAAI7F,aAAJ;EACA,IAAIE,cAAJ;;EAEAwG,SAAS,GAAG,UAAWC,CAAX,EAAe;IAE1B,MAAM5C,OAAO,GAAG4C,CAAC,CAACC,IAAlB;;IAEA,QAAS7C,OAAO,CAACF,IAAjB;MAEC,KAAK,MAAL;QACC7D,aAAa,GAAG+D,OAAO,CAAC/D,aAAxB;QACAE,cAAc,GAAG,IAAIsD,OAAJ,CAAa,UAAWC;QAAO;QAAlB,EAAiC;UAE9DzD,aAAa,CAACuH,cAAd,GAA+B,UAAWC,KAAX,EAAmB;YAEjD;YACA/D,OAAO,CAAE;cAAE+D,KAAK,EAAEA;YAAT,CAAF,CAAP;UAEA,CALD;;UAOAC,kBAAkB,CAAEzH,aAAF,CAAlB,CAT8D,CASzB;QAErC,CAXgB,CAAjB;QAYA;;MAED,KAAK,QAAL;QACC,MAAM8B,MAAM,GAAGiC,OAAO,CAACjC,MAAvB;QACA,MAAMM,UAAU,GAAG2B,OAAO,CAAC3B,UAA3B;QACAlC,cAAc,CAACqC,IAAf,CAAuBmF,MAAF,IAAc;UAElC,MAAMF,KAAK,GAAGE,MAAM,CAACF,KAArB;UACA,MAAMG,OAAO,GAAG,IAAIH,KAAK,CAACI,OAAV,EAAhB;UACA,MAAMC,aAAa,GAAG,IAAIL,KAAK,CAACM,aAAV,EAAtB;UACAD,aAAa,CAACE,IAAd,CAAoB,IAAIC,SAAJ,CAAelG,MAAf,CAApB,EAA6CA,MAAM,CAACkB,UAApD;;UAEA,IAAI;YAEH,MAAMiB,QAAQ,GAAG3B,cAAc,CAAEkF,KAAF,EAASG,OAAT,EAAkBE,aAAlB,EAAiCzF,UAAjC,CAA/B;YAEA,MAAM6F,OAAO,GAAGhE,QAAQ,CAACQ,UAAT,CAAoB2C,GAApB,CAA2Bc,IAAF,IAAYA,IAAI,CAAC3D,KAAL,CAAWzC,MAAhD,CAAhB;YAEA,IAAKmC,QAAQ,CAACI,KAAd,EAAsB4D,OAAO,CAAC1C,IAAR,CAActB,QAAQ,CAACI,KAAT,CAAeE,KAAf,CAAqBzC,MAAnC;YAEtBqG,IAAI,CAACvE,WAAL,CAAkB;cAAEC,IAAI,EAAE,QAAR;cAAkBC,EAAE,EAAEC,OAAO,CAACD,EAA9B;cAAkCG;YAAlC,CAAlB,EAAgEgE,OAAhE;UAEA,CAVD,CAUE,OAAQnB,KAAR,EAAgB;YAEjBD,OAAO,CAACC,KAAR,CAAeA,KAAf;YAEAqB,IAAI,CAACvE,WAAL,CAAkB;cAAEC,IAAI,EAAE,OAAR;cAAiBC,EAAE,EAAEC,OAAO,CAACD,EAA7B;cAAiCgD,KAAK,EAAEA,KAAK,CAAC/C;YAA9C,CAAlB;UAEA,CAhBD,SAgBU;YAETyD,KAAK,CAACY,OAAN,CAAeP,aAAf;YACAL,KAAK,CAACY,OAAN,CAAeT,OAAf;UAEA;QAED,CA9BD;QA+BA;IApDF;EAwDA,CA5DD;;EA8DA,SAASrF,cAAT,CAAyBkF,KAAzB,EAAgCG,OAAhC,EAAyCE,aAAzC,EAAwDzF,UAAxD,EAAqE;IAEpE,MAAMF,YAAY,GAAGE,UAAU,CAACF,YAAhC;IACA,MAAMC,cAAc,GAAGC,UAAU,CAACD,cAAlC;IAEA,IAAIkG,aAAJ;IACA,IAAIC,cAAJ;IAEA,MAAMC,YAAY,GAAGZ,OAAO,CAACa,sBAAR,CAAgCX,aAAhC,CAArB;;IAEA,IAAKU,YAAY,KAAKf,KAAK,CAACiB,eAA5B,EAA8C;MAE7CJ,aAAa,GAAG,IAAIb,KAAK,CAACkB,IAAV,EAAhB;MACAJ,cAAc,GAAGX,OAAO,CAACgB,kBAAR,CAA4Bd,aAA5B,EAA2CQ,aAA3C,CAAjB;IAEA,CALD,MAKO,IAAKE,YAAY,KAAKf,KAAK,CAACoB,WAA5B,EAA0C;MAEhDP,aAAa,GAAG,IAAIb,KAAK,CAACqB,UAAV,EAAhB;MACAP,cAAc,GAAGX,OAAO,CAACmB,wBAAR,CAAkCjB,aAAlC,EAAiDQ,aAAjD,CAAjB;IAEA,CALM,MAKA;MAEN,MAAM,IAAIpF,KAAJ,CAAW,8CAAX,CAAN;IAEA;;IAED,IAAK,CAAEqF,cAAc,CAACS,EAAf,EAAF,IAAyBV,aAAa,CAACW,GAAd,KAAsB,CAApD,EAAwD;MAEvD,MAAM,IAAI/F,KAAJ,CAAW,yCAAyCqF,cAAc,CAACW,SAAf,EAApD,CAAN;IAEA;;IAED,MAAMhF,QAAQ,GAAG;MAAEI,KAAK,EAAE,IAAT;MAAeI,UAAU,EAAE;IAA3B,CAAjB,CAhCoE,CAkCpE;;IACA,KAAM,MAAMyE,aAAZ,IAA6BhH,YAA7B,EAA4C;MAE3C,MAAMiH,aAAa,GAAGhB,IAAI,CAAEhG,cAAc,CAAE+G,aAAF,CAAhB,CAA1B;MAEA,IAAIvE,SAAJ;MACA,IAAIyE,WAAJ,CAL2C,CAO3C;MACA;MACA;MACA;;MACA,IAAKhH,UAAU,CAACC,YAAhB,EAA+B;QAE9B+G,WAAW,GAAGlH,YAAY,CAAEgH,aAAF,CAA1B;QACAvE,SAAS,GAAGgD,OAAO,CAAC0B,sBAAR,CAAgChB,aAAhC,EAA+Ce,WAA/C,CAAZ;MAEA,CALD,MAKO;QAENA,WAAW,GAAGzB,OAAO,CAAC2B,cAAR,CAAwBjB,aAAxB,EAAuCb,KAAK,CAAEtF,YAAY,CAAEgH,aAAF,CAAd,CAA5C,CAAd;QAEA,IAAKE,WAAW,KAAK,CAAE,CAAvB,EAA2B;QAE3BzE,SAAS,GAAGgD,OAAO,CAAC4B,YAAR,CAAsBlB,aAAtB,EAAqCe,WAArC,CAAZ;MAEA;;MAEDnF,QAAQ,CAACQ,UAAT,CAAoBc,IAApB,CAA0BiE,eAAe,CAAEhC,KAAF,EAASG,OAAT,EAAkBU,aAAlB,EAAiCa,aAAjC,EAAgDC,aAAhD,EAA+DxE,SAA/D,CAAzC;IAEA,CA/DmE,CAiEpE;;;IACA,IAAK4D,YAAY,KAAKf,KAAK,CAACiB,eAA5B,EAA8C;MAE7CxE,QAAQ,CAACI,KAAT,GAAiBoF,WAAW,CAAEjC,KAAF,EAASG,OAAT,EAAkBU,aAAlB,CAA5B;IAEA;;IAEDb,KAAK,CAACY,OAAN,CAAeC,aAAf;IAEA,OAAOpE,QAAP;EAEA;;EAED,SAASwF,WAAT,CAAsBjC,KAAtB,EAA6BG,OAA7B,EAAsCU,aAAtC,EAAsD;IAErD,MAAMqB,QAAQ,GAAGrB,aAAa,CAACsB,SAAd,EAAjB;IACA,MAAMC,UAAU,GAAGF,QAAQ,GAAG,CAA9B;IACA,MAAM1G,UAAU,GAAG4G,UAAU,GAAG,CAAhC;;IAEA,MAAMZ,GAAG,GAAGxB,KAAK,CAACqC,OAAN,CAAe7G,UAAf,CAAZ;;IACA2E,OAAO,CAACmC,uBAAR,CAAiCzB,aAAjC,EAAgDrF,UAAhD,EAA4DgG,GAA5D;IACA,MAAM3E,KAAK,GAAG,IAAI0F,WAAJ,CAAiBvC,KAAK,CAACwC,OAAN,CAAclI,MAA/B,EAAuCkH,GAAvC,EAA4CY,UAA5C,EAAyDK,KAAzD,EAAd;;IACAzC,KAAK,CAAC0C,KAAN,CAAalB,GAAb;;IAEA,OAAO;MAAEzE,KAAK,EAAEF,KAAT;MAAgBQ,QAAQ,EAAE;IAA1B,CAAP;EAEA;;EAED,SAAS2E,eAAT,CAA0BhC,KAA1B,EAAiCG,OAAjC,EAA0CU,aAA1C,EAAyDa,aAAzD,EAAwEC,aAAxE,EAAuFxE,SAAvF,EAAmG;IAElG,MAAMwF,aAAa,GAAGxF,SAAS,CAACyF,cAAV,EAAtB;IACA,MAAMC,SAAS,GAAGhC,aAAa,CAACiC,UAAd,EAAlB;IACA,MAAMC,SAAS,GAAGF,SAAS,GAAGF,aAA9B;IACA,MAAMnH,UAAU,GAAGuH,SAAS,GAAGpB,aAAa,CAACqB,iBAA7C;IACA,MAAMC,QAAQ,GAAGC,gBAAgB,CAAElD,KAAF,EAAS2B,aAAT,CAAjC;;IAEA,MAAMH,GAAG,GAAGxB,KAAK,CAACqC,OAAN,CAAe7G,UAAf,CAAZ;;IACA2E,OAAO,CAACgD,iCAAR,CAA2CtC,aAA3C,EAA0D1D,SAA1D,EAAqE8F,QAArE,EAA+EzH,UAA/E,EAA2FgG,GAA3F;IACA,MAAMzE,KAAK,GAAG,IAAI4E,aAAJ,CAAmB3B,KAAK,CAACwC,OAAN,CAAclI,MAAjC,EAAyCkH,GAAzC,EAA8CuB,SAA9C,EAA0DN,KAA1D,EAAd;;IACAzC,KAAK,CAAC0C,KAAN,CAAalB,GAAb;;IAEA,OAAO;MACNpE,IAAI,EAAEsE,aADA;MAEN3E,KAAK,EAAEA,KAFD;MAGNM,QAAQ,EAAEsF;IAHJ,CAAP;EAMA;;EAED,SAASO,gBAAT,CAA2BlD,KAA3B,EAAkC2B,aAAlC,EAAkD;IAEjD,QAASA,aAAT;MAEC,KAAKyB,YAAL;QAAmB,OAAOpD,KAAK,CAACqD,UAAb;;MACnB,KAAK7C,SAAL;QAAgB,OAAOR,KAAK,CAACsD,OAAb;;MAChB,KAAKC,UAAL;QAAiB,OAAOvD,KAAK,CAACwD,QAAb;;MACjB,KAAKC,UAAL;QAAiB,OAAOzD,KAAK,CAAC0D,QAAb;;MACjB,KAAKC,UAAL;QAAiB,OAAO3D,KAAK,CAAC4D,QAAb;;MACjB,KAAKC,WAAL;QAAkB,OAAO7D,KAAK,CAAC8D,SAAb;;MAClB,KAAKvB,WAAL;QAAkB,OAAOvC,KAAK,CAAC+D,SAAb;IARnB;EAYA;AAED;;AAED,SAAS3L,WAAT"},"metadata":{},"sourceType":"module"}