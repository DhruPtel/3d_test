{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/User/don1/depend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { utils } from 'ethers';\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\nexport function warnOnInvalidCall(call) {\n  if (!call) {\n    return;\n  }\n\n  var contract = call.contract,\n      method = call.method,\n      args = call.args;\n  console.warn(\"Invalid contract call: address=\".concat(contract.address, \" method=\").concat(method, \" args=\").concat(args));\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\nexport function encodeCallData(call, chainId) {\n  if (!call) {\n    return undefined;\n  }\n\n  var contract = call.contract,\n      method = call.method,\n      args = call.args;\n\n  if (!contract.address || !method) {\n    warnOnInvalidCall(call);\n    return undefined;\n  }\n\n  try {\n    return {\n      address: contract.address,\n      data: contract.interface.encodeFunctionData(method, args),\n      chainId: chainId\n    };\n  } catch (_a) {\n    warnOnInvalidCall(call);\n    return undefined;\n  }\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\nexport function getUniqueCalls(requests) {\n  var unique = [];\n  var used = {};\n\n  var _iterator = _createForOfIteratorHelper(requests),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var request = _step.value;\n\n      if (!used[\"\".concat(request.address.toLowerCase()).concat(request.data).concat(request.chainId)]) {\n        unique.push(request);\n        used[\"\".concat(request.address.toLowerCase()).concat(request.data).concat(request.chainId)] = true;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return unique;\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\nexport function decodeCallResult(call, result) {\n  if (!result || !call) {\n    return undefined;\n  }\n\n  var value = result.value,\n      success = result.success;\n\n  try {\n    if (success) {\n      return {\n        value: call.contract.interface.decodeFunctionResult(call.method, value),\n        error: undefined\n      };\n    } else {\n      var errorMessage = new utils.Interface(['function Error(string)']).decodeFunctionData('Error', value)[0];\n      return {\n        value: undefined,\n        error: new Error(errorMessage)\n      };\n    }\n  } catch (error) {\n    return {\n      value: undefined,\n      error: error\n    };\n  }\n}","map":{"version":3,"sources":["../../../../src/helpers/calls.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { utils } from 'ethers';\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function warnOnInvalidCall(call) {\n    if (!call) {\n        return;\n    }\n    const { contract, method, args } = call;\n    console.warn(`Invalid contract call: address=${contract.address} method=${method} args=${args}`);\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function encodeCallData(call, chainId) {\n    if (!call) {\n        return undefined;\n    }\n    const { contract, method, args } = call;\n    if (!contract.address || !method) {\n        warnOnInvalidCall(call);\n        return undefined;\n    }\n    try {\n        return { address: contract.address, data: contract.interface.encodeFunctionData(method, args), chainId };\n    }\n    catch (_a) {\n        warnOnInvalidCall(call);\n        return undefined;\n    }\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function getUniqueCalls(requests) {\n    const unique = [];\n    const used = {};\n    for (const request of requests) {\n        if (!used[`${request.address.toLowerCase()}${request.data}${request.chainId}`]) {\n            unique.push(request);\n            used[`${request.address.toLowerCase()}${request.data}${request.chainId}`] = true;\n        }\n    }\n    return unique;\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function decodeCallResult(call, result) {\n    if (!result || !call) {\n        return undefined;\n    }\n    const { value, success } = result;\n    try {\n        if (success) {\n            return {\n                value: call.contract.interface.decodeFunctionResult(call.method, value),\n                error: undefined,\n            };\n        }\n        else {\n            const errorMessage = new utils.Interface(['function Error(string)']).decodeFunctionData('Error', value)[0];\n            return {\n                value: undefined,\n                error: new Error(errorMessage),\n            };\n        }\n    }\n    catch (error) {\n        return {\n            value: undefined,\n            error: error,\n        };\n    }\n}\n//# sourceMappingURL=calls.js.map"]},"metadata":{},"sourceType":"module"}