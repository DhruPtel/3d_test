{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/User/don1/depend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _slicedToArray from \"C:/Users/User/don1/depend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _asyncToGenerator from \"C:/Users/User/don1/depend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useCallback, useEffect, useReducer, useState } from 'react';\nimport { NetworkContext } from './context';\nimport { defaultNetworkState, networksReducer } from './reducer';\nimport { Web3Provider, Provider } from '@ethersproject/providers';\nimport { subscribeToProviderEvents, getInjectedProvider } from '../../../helpers';\nimport { useConfig } from '../../config';\nimport { useLocalStorage } from '../../../hooks';\nimport detectEthereumProvider from '@metamask/detect-provider';\n\nfunction tryToGetAccount(_x) {\n  return _tryToGetAccount.apply(this, arguments);\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\n\nfunction _tryToGetAccount() {\n  _tryToGetAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(provider) {\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.prev = 0;\n            _context4.next = 3;\n            return provider.getSigner().getAddress();\n\n          case 3:\n            return _context4.abrupt(\"return\", _context4.sent);\n\n          case 6:\n            _context4.prev = 6;\n            _context4.t0 = _context4[\"catch\"](0);\n\n            if (!(_context4.t0.code === 'UNSUPPORTED_OPERATION')) {\n              _context4.next = 10;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", undefined);\n\n          case 10:\n            throw _context4.t0;\n\n          case 11:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4, null, [[0, 6]]);\n  }));\n  return _tryToGetAccount.apply(this, arguments);\n}\n\nexport function NetworkProvider(_ref) {\n  var children = _ref.children,\n      providerOverride = _ref.providerOverride;\n\n  var _useConfig = useConfig(),\n      autoConnect = _useConfig.autoConnect,\n      pollingInterval = _useConfig.pollingInterval;\n\n  var _useReducer = useReducer(networksReducer, defaultNetworkState),\n      _useReducer2 = _slicedToArray(_useReducer, 2),\n      network = _useReducer2[0],\n      dispatch = _useReducer2[1];\n\n  var _useState = useState(function () {\n    return function () {\n      return undefined;\n    };\n  }),\n      _useState2 = _slicedToArray(_useState, 2),\n      onUnsubscribe = _useState2[0],\n      setOnUnsubscribe = _useState2[1];\n\n  var _useLocalStorage = useLocalStorage('shouldConnectMetamask'),\n      _useLocalStorage2 = _slicedToArray(_useLocalStorage, 2),\n      shouldConnectMetamask = _useLocalStorage2[0],\n      setShouldConnectMetamask = _useLocalStorage2[1];\n\n  var _useState3 = useState(false),\n      _useState4 = _slicedToArray(_useState3, 2),\n      isLoading = _useState4[0],\n      setLoading = _useState4[1];\n\n  var activateBrowserWallet = useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var injectedProvider;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            setLoading(true);\n            _context.next = 3;\n            return getInjectedProvider(pollingInterval);\n\n          case 3:\n            injectedProvider = _context.sent;\n\n            if (injectedProvider) {\n              _context.next = 8;\n              break;\n            }\n\n            reportError(new Error('No injected provider available'));\n            setLoading(false);\n            return _context.abrupt(\"return\");\n\n          case 8:\n            _context.prev = 8;\n            _context.next = 11;\n            return injectedProvider.send('eth_requestAccounts', []);\n\n          case 11:\n            setShouldConnectMetamask(true);\n            _context.next = 19;\n            break;\n\n          case 14:\n            _context.prev = 14;\n            _context.t0 = _context[\"catch\"](8);\n            reportError(_context.t0);\n            setShouldConnectMetamask(false);\n            throw _context.t0;\n\n          case 19:\n            _context.prev = 19;\n            setLoading(false);\n            return _context.finish(19);\n\n          case 22:\n            return _context.abrupt(\"return\", activate(injectedProvider));\n\n          case 23:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[8, 14, 19, 22]]);\n  })), []);\n  useEffect(function () {\n    if (providerOverride) {\n      activate(providerOverride);\n    }\n  }, [providerOverride]);\n  var update = useCallback(function (newNetwork) {\n    dispatch({\n      type: 'UPDATE_NETWORK',\n      network: newNetwork\n    });\n  }, [network]);\n  var reportError = useCallback(function (error) {\n    console.error(error);\n    dispatch({\n      type: 'ADD_ERROR',\n      error: error\n    });\n  }, []);\n  var deactivate = useCallback(function () {\n    setShouldConnectMetamask(false);\n    update({\n      accounts: []\n    });\n  }, []);\n  var onDisconnect = useCallback(function (error) {\n    deactivate();\n    reportError(error);\n  }, []);\n  useEffect(function () {\n    setTimeout( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n      var _a, _b, _c;\n\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.prev = 0;\n\n              if (!(shouldConnectMetamask && autoConnect && !providerOverride)) {\n                _context2.next = 8;\n                break;\n              }\n\n              _context2.next = 4;\n              return detectEthereumProvider();\n\n            case 4:\n              if (!(shouldConnectMetamask && ((_c = (_b = (_a = window.ethereum) === null || _a === void 0 ? void 0 : _a._state) === null || _b === void 0 ? void 0 : _b.accounts) === null || _c === void 0 ? void 0 : _c.length) === 0)) {\n                _context2.next = 6;\n                break;\n              }\n\n              return _context2.abrupt(\"return\");\n\n            case 6:\n              _context2.next = 8;\n              return activateBrowserWallet();\n\n            case 8:\n              _context2.next = 13;\n              break;\n\n            case 10:\n              _context2.prev = 10;\n              _context2.t0 = _context2[\"catch\"](0);\n              console.warn(_context2.t0);\n\n            case 13:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[0, 10]]);\n    })));\n  }, [shouldConnectMetamask, autoConnect, providerOverride]);\n  var activate = useCallback( /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(provider) {\n      var _a, wrappedProvider, account, chainId, clearSubscriptions;\n\n      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              wrappedProvider = Provider.isProvider(provider) ? provider : new Web3Provider(provider);\n              _context3.prev = 1;\n              setLoading(true);\n              _context3.next = 5;\n              return tryToGetAccount(wrappedProvider);\n\n            case 5:\n              account = _context3.sent;\n              _context3.next = 8;\n              return wrappedProvider.getNetwork();\n\n            case 8:\n              _context3.t1 = _a = _context3.sent;\n              _context3.t0 = _context3.t1 === null;\n\n              if (_context3.t0) {\n                _context3.next = 12;\n                break;\n              }\n\n              _context3.t0 = _a === void 0;\n\n            case 12:\n              if (!_context3.t0) {\n                _context3.next = 16;\n                break;\n              }\n\n              _context3.t2 = void 0;\n              _context3.next = 17;\n              break;\n\n            case 16:\n              _context3.t2 = _a.chainId;\n\n            case 17:\n              chainId = _context3.t2;\n              onUnsubscribe();\n              clearSubscriptions = subscribeToProviderEvents(wrappedProvider.provider, update, onDisconnect);\n              setOnUnsubscribe(function () {\n                return clearSubscriptions;\n              });\n              update({\n                provider: wrappedProvider,\n                chainId: chainId,\n                accounts: account ? [account] : []\n              });\n              _context3.next = 28;\n              break;\n\n            case 24:\n              _context3.prev = 24;\n              _context3.t3 = _context3[\"catch\"](1);\n              reportError(_context3.t3);\n              throw _context3.t3;\n\n            case 28:\n              _context3.prev = 28;\n              setLoading(false);\n              return _context3.finish(28);\n\n            case 31:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3, null, [[1, 24, 28, 31]]);\n    }));\n\n    return function (_x2) {\n      return _ref4.apply(this, arguments);\n    };\n  }(), [onUnsubscribe]);\n  return _jsx(NetworkContext.Provider, {\n    value: {\n      network: network,\n      update: update,\n      activate: activate,\n      deactivate: deactivate,\n      reportError: reportError,\n      activateBrowserWallet: activateBrowserWallet,\n      isLoading: isLoading\n    },\n    children: children\n  });\n}","map":{"version":3,"sources":["../../../../../../src/providers/network/network/provider.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useCallback, useEffect, useReducer, useState } from 'react';\nimport { NetworkContext } from './context';\nimport { defaultNetworkState, networksReducer } from './reducer';\nimport { Web3Provider, Provider } from '@ethersproject/providers';\nimport { subscribeToProviderEvents, getInjectedProvider } from '../../../helpers';\nimport { useConfig } from '../../config';\nimport { useLocalStorage } from '../../../hooks';\nimport detectEthereumProvider from '@metamask/detect-provider';\nasync function tryToGetAccount(provider) {\n    try {\n        return await provider.getSigner().getAddress();\n    }\n    catch (err) {\n        if (err.code === 'UNSUPPORTED_OPERATION') {\n            // readonly provider\n            return undefined;\n        }\n        throw err;\n    }\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function NetworkProvider({ children, providerOverride }) {\n    const { autoConnect, pollingInterval } = useConfig();\n    const [network, dispatch] = useReducer(networksReducer, defaultNetworkState);\n    const [onUnsubscribe, setOnUnsubscribe] = useState(() => () => undefined);\n    const [shouldConnectMetamask, setShouldConnectMetamask] = useLocalStorage('shouldConnectMetamask');\n    const [isLoading, setLoading] = useState(false);\n    const activateBrowserWallet = useCallback(async () => {\n        setLoading(true);\n        const injectedProvider = await getInjectedProvider(pollingInterval);\n        if (!injectedProvider) {\n            reportError(new Error('No injected provider available'));\n            setLoading(false);\n            return;\n        }\n        try {\n            await injectedProvider.send('eth_requestAccounts', []);\n            setShouldConnectMetamask(true);\n        }\n        catch (err) {\n            reportError(err);\n            setShouldConnectMetamask(false);\n            throw err;\n        }\n        finally {\n            setLoading(false);\n        }\n        return activate(injectedProvider);\n    }, []);\n    useEffect(() => {\n        if (providerOverride) {\n            activate(providerOverride);\n        }\n    }, [providerOverride]);\n    const update = useCallback((newNetwork) => {\n        dispatch({ type: 'UPDATE_NETWORK', network: newNetwork });\n    }, [network]);\n    const reportError = useCallback((error) => {\n        console.error(error);\n        dispatch({ type: 'ADD_ERROR', error });\n    }, []);\n    const deactivate = useCallback(() => {\n        setShouldConnectMetamask(false);\n        update({\n            accounts: [],\n        });\n    }, []);\n    const onDisconnect = useCallback((error) => {\n        deactivate();\n        reportError(error);\n    }, []);\n    useEffect(() => {\n        setTimeout(async () => {\n            var _a, _b, _c;\n            try {\n                if (shouldConnectMetamask && autoConnect && !providerOverride) {\n                    await detectEthereumProvider();\n                    // If window.ethereum._state.accounts is non null but has no items,\n                    // it probably means that the user has disconnected Metamask manually.\n                    if (shouldConnectMetamask && ((_c = (_b = (_a = window.ethereum) === null || _a === void 0 ? void 0 : _a._state) === null || _b === void 0 ? void 0 : _b.accounts) === null || _c === void 0 ? void 0 : _c.length) === 0) {\n                        return;\n                    }\n                    await activateBrowserWallet();\n                }\n            }\n            catch (err) {\n                console.warn(err);\n            }\n        });\n    }, [shouldConnectMetamask, autoConnect, providerOverride]);\n    const activate = useCallback(async (provider) => {\n        var _a;\n        const wrappedProvider = Provider.isProvider(provider) ? provider : new Web3Provider(provider);\n        try {\n            setLoading(true);\n            const account = await tryToGetAccount(wrappedProvider);\n            const chainId = (_a = (await wrappedProvider.getNetwork())) === null || _a === void 0 ? void 0 : _a.chainId;\n            onUnsubscribe();\n            const clearSubscriptions = subscribeToProviderEvents(wrappedProvider.provider, update, onDisconnect);\n            setOnUnsubscribe(() => clearSubscriptions);\n            update({\n                provider: wrappedProvider,\n                chainId,\n                accounts: account ? [account] : [],\n            });\n        }\n        catch (err) {\n            reportError(err);\n            throw err;\n        }\n        finally {\n            setLoading(false);\n        }\n    }, [onUnsubscribe]);\n    return (_jsx(NetworkContext.Provider, { value: { network, update, activate, deactivate, reportError, activateBrowserWallet, isLoading }, children: children }));\n}\n//# sourceMappingURL=provider.js.map"]},"metadata":{},"sourceType":"module"}